%!TEX root = ../dokumentation.tex

\chapter{Fazit}

%title wird unter dem Bsp. abgedruckt
%caption wird im Verzeichnis abgedruckt
%label wird zum referenzieren benutzt, muss einzigartig sein.
\section{Zusammenfassung}
Zusammenfassend kann festgehalten werden, dass der im Rahmen dieser
Studienarbeit entstanden Musikplayer für den Raspberry Pi, sich in einem
Zustand befindet, in welchem er so gut wie alle zu Beginn definierten
Anforderungen erfüllen kann. Er ist in der Lage Musik zu starten, stoppen oder
zu pausieren, er kann die Audiolautstärke anpassen, Lieder überspringen, Lieder
zu einer Warteschlange hinzufügen oder auch einzelne Lieder wieder löschen. Die
einzige Funktionalität, welche bislang noch nicht implementiert wurde, ist das
Fade-In und Fade-Out von Liedern. Die Problemantik hinter dieser Funktion ist
es, dass wir bislang noch keine Möglichkeit gefunden haben, wie wir uns die
aktuelle Position eines Liedes während des Abspielens auslesen können. 


\section{Reflexion}
Im Rahmen der Studienarbeit konnte viel neues Wissen transferiert werden. So
hatten wir beispielsweise unser ersten Berührungspunkte mit der
Programmiersprache Go, welche sich in den letzten Jahren immer größerer
Beliebtheit erfreut. (%todo: add stack overflow reference%) 
Insgesamt fiel uns das Lernen von Go sehr leicht, da die Sprache von der Syntax
her sehr an C erinnert, aber dennoch von den Bibliotheken her sehr umfangreich
ist. \newline

Das Entwickeln mit dem Raspberry Pi ist uns auch leichter gefallen, als zu
beginn vermutet. Es hat uns sehr fasziniert, was man mit so einem kleinen
Minicomputer alles anstellen kann. Ansonsten verlief das Arbeiten mit dem
Raspberry Pi reibungslos, was unter anderem daran gelegen haben könnte, dass
Raspbian ein Debian-basiertes Betriebssystem ist, und so sich nicht all zu sehr
von anderen Debian-basierten Distributionen unterscheidet.  \newline

Die Entwicklung als Zweierteam lief zusammenfassend sehr gut ab.
Zu beginn lief die Entwicklung als Zweierteam noch etwas chaotisch ab, aber
nachdem wir uns auf ein finales Grundkonzept geeinigt hatten, funktionierte die
Zusammenarbeit doch sehr gut. Wir haben bei der Umsetzungen die Entwicklung
verschiedener Funktionalitäten unter uns aufgeteilt und uns ansonsten sehr oft
zu Besprechungen zusammengesetzt. Ansonsten haben wir sehr darauf geachtet, dass
wir gegenseitig über unseren Code drüber schauen, um mögliche Fehler frühstens
entdecken zu können. Als Kritikpunkt sollte noch genannt werden, dass wir uns
zu beginn auf keine wirklichen Kodierrichtlinien geeinigt haben, was bei der
Entwicklung öfter mal zu abweichend  oder ähnliches
geführt. Dies sollte in Zukunft vor der Umsetzung beachtet werden. \newline

Ein weiterer Punkt, welcher beim nächsten Mal noch optimiert werden könnte ist
die Phase der Testung. Wie es in den meisten Softwareprojekten der Fall ist, %todo: reference
kam auch in unserem Projekt die Phase des Testens eher zu kurz. Dabei hätte man
beispielsweise während des Entwicklungsprozesses ohne großen Aufwand statische
Codeanalyse-Tools einsetzen können, um einfache Fehler wie der Einsatz von
unbenutzten Variablen oder auch Race Conditions noch vor dem Ausführen des
Programmes aufzudecken. Des Weiteren hätte man aufbauend auf der
Versionsverwaltung noch Tools zum automatisierten Testen einsetzen können, um
das manuelle Testen zu verringern und so die Effizienz bei der Entwicklung zu
erhöhen.

\begin{comment}
- Codierrichtlinien
- Viel gelernt
- Go als Programmiersprache
- Kommunikation über Sockets zwischen zwei Programmen
- Analyse zu kurz
- Testung zu kurz
  - Countinous Integration
  - Static Code analysis
  - automatic testing with unit test
\end{comment}



\section{Aussicht}
Im Zeitraum der Studienarbeit konnten, abgesehen von der Fade-In und Fade-Out
Funktionalität, alle zu beginn definierten Anforderungen erfüllt werden. Der
dabei entstanden Musikplayer wurde ausgiebig auf dem bereitgestellten Raspberry Pi
getestet, sodass dieser im späteren Einsatzrahmen ohne Probleme funktionieren
sollte. \newline
Wie in den meisten Projekten mit Deadline, konnten im angegeben Zeitraum nicht
alle erdachten Funktionalitäten  perfekt umgesetzt werden. So gibt es bei der
aktuellen Version immernoch Kleinigkeiten, welche bei einem zukünftigen Release
noch hinzugefügt oder verändert werden könnten. \hfill \break

Eines dieser Funktionalitäten betrifft den Austausch von Daten zwischen 
Server und Client. So gibt der Server dem Client aktuell nur einen einfachen
String zurück, welcher Informationen zu der ausgeführten Aktion enthält. Dieser
könnte in Zukunft durch ein \ac{JSON}-Array ersetzt werden, um noch mehr
relevante Informationen mit zu übertragen. Dadurch könnten Informationen wie
Lautstärke oder Warteliste mitübergeben werden, sodass der Client nicht mehr
jede Information manuell erfragen muss. \newline
Wenn man die Kommunikation auf \ac{JSON}-Arrays geändert hätte, könnte man für
den Client auch noch eine kleine \ac{GUI} bauen. Dadurch könnten dem Benutzer alle
aktuellen Informationen angezeigt werden, ohne das manuelle Anfragen durch den
Anwender abgeschickt werden müssen. Zusätzlich könnten in der Benutzeroberfläche
Shortcuts hinterlegt werden, sodass der Benutzer nicht mehr mühselig alle
Befehle einzeln eintragen muss, sondern vordefinierte Tastenkürzel für gängige
Aktionen wie beispielsweise Start, Stop, etc. verwenden kann. Dies würde zu mehr Übersicht
führen und dem Anwender eine leichtere Benutzung ermöglichen. \hfill \break

Ein weiteres optionales Feature, welches in zukünftigen Releases behandelt werden könnte,
ist die Unterstützung von weiteren Audioformaten. Aktuell wird nur das
Audioformat \ac{MP3} unterstützt. Um noch weiter Audioformate wie
beispielsweise \ac{MP4}, \ac{FLAC} oder \ac{WAVE} abzuspielen,
müssten noch weitere Decoder implementiert werden. \newline
Auch wäre es denkbar einen Dienst zum Abspielen von Internet-Streams
hinzuzufügen. So könnte zukünftig das Abspielen von Internet-Radios oder
ähnlichem ermöglicht werden. \hfill \break

Weit in der Zukunft wäre die Änderung der Kommunikationsschnittstelle zwischen
Server und Client denkbar. Aktuell kommunizieren die beiden noch über einen
\textit{\ac{POSIX} local \ac{IPC} Socket}. Dieser ermöglicht nur die lokale
Kommunikationsverbindung zwischen Prozessen. Zukünftig könnte diese durch einen
\textit{WebSocket} ersetzt werden, wodurch eine Kommunikation übers Netzwerk
auch ermöglicht werden würde. Dadurch könnten andere Geräte, welche sich im
gleichen Netzwerk wie der Server befinden, auch Befehle an diesen schicken. 
Im Zuge dessen könnten Netzwerkgeräte wie beispielsweise Sprachsteuerungen in
der Art von \textit{Amazon Echo} oder \textit{Google Home} auch auf den
Musikplayer zugreifen und diesen über Spracheingaben steuern.

\begin{comment}
Was noch gemacht werden kann bzw. was noch coole und Sinnvolle Erweiterungen wären.
\begin{itemize}
\item Zurückkommende Nachricht auch als JSON - dadurch können andere Sachen übergeben werden und nicht nur text
\item kleine GUI die alle aktuelle Informationen die ganze Zeit anzeigt
\item Um mehr Dateitypen zu unterstützen eventuell einen anderen Decoder nutzen.
\item Die Möglichkeit bieten auch einen Internet-Stream abspielen zu können.
\item Client Server Verbindung über TCP machen, sodass die Kommunikation nicht nur auf dem Raspberry Pi stattfindet sondern unabhängig ist.
\item Intergration von Alexa Steuerung (Sehr weit gedacht)
\end{itemize}
\end{comment}

